// NameAndDateRecords.c
// Description: A program that accepts names and birth dates, stores them in dynamically allocated memory, and displays them sorted
// Version: 29August2024
// Copyright: 

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <ctype.h>

#define MAXLENGTH 11
#define MAXCOUNT 5

typedef char* string;

typedef struct {
    string name;
    long birthdate;
} Person;

int validateDate(long date);

int main() {
    int count = 0;
    Person* records[MAXCOUNT];
    char nameInput[MAXLENGTH];
    long birthdate;
    char buffer[50];
    int error = 0;
    string intro = "Records Entry and Sorting Program\nPlease input name & birthday (max: 5 entries).\n";
    string nameInputPrompt = "Name (First Last): ";
    string birthdateInputPrompt = "Birthday (YYYYMMDD): ";
    string nameTemplate = "%-10s %08ld Entry count: %2d malloc-address: %p -> %p\n";
    string sortedRecordsTitle = "\nSorted Records:\n";
    string errorMessage = "Incorrect name format.\n";
    string dateErrorMessage = "Date format error! Please re-enter date (YYYYMMDD).\n";
    string emptyDateErrorMessage = "Empty date error!\n";
    char c;
    int length = 0;
    int i, j;
    Person* temp;

    printf("%s", intro);

    // Get records
    while (count < MAXCOUNT && !error) {
        printf("%s", nameInputPrompt);
        length = 0;
        // Get a name
        while ((c = getchar())) {
            if (c != '\n') {
                if (length < MAXLENGTH - 1) {
                    nameInput[length++] = c;
                }
            } else {
                if (c == '\n' && length > 0) {
                    nameInput[length] = '\0';
                    records[count] = malloc(sizeof(Person));
                    assert(records[count] != NULL);
                    records[count]->name = malloc(strlen(nameInput) + 1);
                    assert(records[count]->name != NULL);
                    strcpy(records[count]->name, nameInput);
                    break;
                } else {
                    error = 1;
                    printf("%s", errorMessage);
                    break;
                }
            }
        }

        if (error) break;

        // Get birthdate
        while (1) {
            printf("%s", birthdateInputPrompt);
            fgets(buffer, sizeof(buffer), stdin);
            if (sscanf(buffer, "%ld", &birthdate) == 1) {
                if (validateDate(birthdate)) {
                    records[count]->birthdate = birthdate;
                    printf(nameTemplate, records[count]->name, records[count]->birthdate, count + 1, (void*)records[count], (void*)records[count]->name);
                    count++;
                    break;
                } else {
                    printf("%s", dateErrorMessage);
                }
            } else if (buffer[0] == '\n') {
                printf("%s", emptyDateErrorMessage);
                error = 1;
                break;
            } else {
                printf("%s", dateErrorMessage);
            }
        }
    }

    if (!error) {
        // Bubble sort the records by name
        for (i = 0; i < count - 1; i++) {
            for (j = i + 1; j < count; j++) {
                if (strcmp(records[i]->name, records[j]->name) > 0) {
                    temp = records[i];
                    records[i] = records[j];
                    records[j] = temp;
                }
            }
        }

        // Show sorted records
        printf("%s", sortedRecordsTitle);
        for (i = 0; i < count; i++) {
            printf(nameTemplate, records[i]->name, records[i]->birthdate, i + 1, (void*)records[i], (void*)records[i]->name);
            free(records[i]->name);
            free(records[i]);
        }
    }

    return 0;
}

// Validate the date
int validateDate(long date) {
    int year = date / 10000;
    int month = (date / 100) % 100;
    int day = date % 100;

    if (year < 0 || year > 9999) return 0;
    if (month < 1 || month > 12) return 0;
    if (day < 1) return 0;

    if (month == 2) {
        if (day > 28) return 0; // Not handling leap years
    } else if (month == 4 || month == 6 || month == 9 || month == 11) {
        if (day > 30) return 0;
    } else {
        if (day > 31) return 0;
    }

    return 1;
}
